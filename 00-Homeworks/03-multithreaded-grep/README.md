# Multithreaded Grep

### Условие

Всяка операционна система предлага функционалност за търсене на низ във файлове: като например конзолната команда [`grep`](https://en.wikipedia.org/wiki/Grep) в Unix/Linux.
Ще създадем програма за претърсване на директорно дърво с текстови файлове за даден низ.

В едно директорно дърво може да има:

1. поддиректории, на произволна дълбочина на влагане
2. текстови файлове

Целта на програмата е да намери всички срещания на даден символен низ в текстовите файлове в това дърво.

За всяко такова срещане, на конзолата или в определен файл **(в зависимост от подадените параметри)** трябва да се изведе ред в следния формат:

```
path:line_number:line_text
```

където: 

* `path` е относителният път на файла спрямо началната директория
* `line_number` е номерът на реда във файла, като броенето започва от 1
* `line_text` е съдържанието на реда, включващ търсения низ

С цел ефективност, решението трябва да е многонишково, т.е. няколко паралелно изпълняващи се нишки трябва да си разпределят работата, като се синхронизират по подходящ начин, така че резултатът да е коректен.

Нека главният клас се казва `Main` и се намира в пакет `bg.sofia.uni.fmi.mjt.grep`. Той ще чете от конзолата `grep` команди и ще ги изпълнява.
Всяка `grep` команда има следния вид:

**grep** \*[-w|-i] [**string_to_find**] [**path_to_directory_tree**] [**number_of_parallel_threads**] \*[path_to_output_file]

1. *-w|-i* - **параметри по избор**
    - -w - указва на `grep` командата да търси само цели думи (т.е "hi" няма да `match`-не "hippo", но ще `match`-не "hi there")
    - -i - указва на `grep` командата да игнорира `case sensitivity` (т.е "hi" e същото като "Hi")
2. *string_to_find* - търсения низ
3. *path_to_directory_tree* - път до корена на директорното дърво
4. *number_of_parallel_threads* - максималния брой паралелно изпълняващи се нишки
5. *path_to_output_file* (**параметър по избор**) - път до файл, в който да се запише изходът от изпълнението на командата `grep`. Ако този параметър не е указан, тогава изходът от програмата трябва да се изведе на конзолата.

\*параметри по избор

Забележки:

1. Има различни валидни начини алгоритъмът да се паралелизира, т.е. да се възползва от наличието на няколко нишки
2. В зависимост от операционната система, вида storage, който ползва файловата система (HDD, SSD) и т.н. ще забележите, че броят паралелни нишки от един момент нататък не подобрява бързодействието, а може дори да го забави. Това е очаквано и не е признак, че решението ви не е коректно.
3. След изпълнението на grep операцията вашият java процес трябва да приключи и да освободи алокираните ресурси.
4. Уверете се, че решенията ви биха работили коректно под всякаква операционна система. Т.е уверете се, че не сте hard-code-нали нещо специфично за операционната система (като path separator).

### Примери

```bash
grep foo /Users/my-user/git/java-course 2
01-intro-to-java/lab/02-anagrams/AnagramTest.java:73:		assertFalse(anagram.isAnagram("food fd"));
06-io-streams/lecture/PITCHME.md:633:// -> "Unable to open file 'food': No such file or directory"
# [...]

grep -w -i foo /Users/my-user/git/java-course 4 /Users/my-user/output.txt  # unix
grep -w foo C:\Users\my-user\java-course 4                                 # windows
grep -wi foo C:\Users\my-user\java-course 4 C:\Users\my-user\output.txt    # windows
```

### Качване в `grader`-a

Качете `zip` архив на директорията `src`.

### Оценяване

Решението може да ви донесе до 100 точки, като ще бъде оценявано:

* за функционална пълнота и коректност
* за ефективност
* за добър дизайн и чист код
